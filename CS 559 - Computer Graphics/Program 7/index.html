<!DOCTYPE html>
<html>
<head>
    <meta name="description" content="Lacey - Programming Assignment 7">
    <meta charset="utf-8">
    <title>Lacey - Programming Assignment 7</title>
    
    <link rel="stylesheet" type="text/css" href="incl/style.css" />
    
    <!-- load shaders into header -->
    <script src="shaders/vertex/simple.js"></script>
    <script src="shaders/fragment/checkerboard.js"></script>
    <script src="shaders/fragment/video.js"></script>
    
    <!-- load 3d object classes -->
    <script src="objects/Icosahedron.js"></script>
    <script src="objects/Plane.js"></script>

    <!-- load TWGL -->
    <script src="https://graphics.cs.wisc.edu/JS/twgl-full.min.js"></script>
</head>
<body>
    <div id="canvasContainer">
        <canvas id="myCanvas"></canvas>
    </div>
    <div id="textOverlay">
        Graphics Town: By Bunny Lacey<br />
        Use WASD to move, space bar to jump<br />
        Webcam enable for video texture on ball.<br />
        Try clicking just above then below your eye in the video feed.<br />
        <div id="controlsContainer">
            Camera:<select id="cntrl_camera"><option>Ball</option></select>:<button id="btn_reset_camera">Reset Camera</button><br />
            View:<select id="cntrl_view"><option value="-1">World</option></select><br />
            <span style="width: 150px; display: inline-block;">Run:<input id="Run" type="checkbox" checked="checked"></span><br />
            <span style="width: 300px; display: inline-block;">Time Of Day:<input id="cntrl_tod" type="range" width="200" min="0" max="1440" step="1"></span>
        </div>
    </div>
    <div id="cameraStream">
            <video id="video" width="320" height="240" autoplay playsinline></video>
    </div>
    <div id="FPSContainer"></div>
</body>

<script>
    "use strict"

    // timing variables
    var currentTime = performance.now();
    var lastTime = currentTime;
    var updateTime = currentTime;
    var frameCount = 0;
    var fps = 1000.0 / 60.0;    // Target frames per second
    var delta = 1.0;            // delta time multiplier between each frame

    // pointers to user interface controls
    const cntrl_camera = document.getElementById('cntrl_camera');         // camera selector
    const btn_reset_camera = document.getElementById('btn_reset_camera'); // reset current camera button
    const cntrl_view = document.getElementById('cntrl_view');             // object view selector
    const cntrl_tod = document.getElementById('cntrl_tod');               // time of day range object
    
    // keyboard input status
    var keyboard_input = new Array(128).fill(0);
    var key_space = false;

    // mouse position data
    var mouseX = 0;
    var mouseY = 0;

    // main canvas and webgl pointer
    const canvas = document.getElementById('myCanvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext('webgl');
    gl.getExtension('OES_standard_derivatives');
    gl.getExtension('EXT_shader_texture_lod');

    // twgl linear algebra helper
    var m4 = twgl.m4;

    var vPlaying = false;
    var vTime = 0;
    var vTimeupdate = false;
    const video = document.getElementById('video');
    video.onclick = videoClick;
    // will set to true when video can be copied to texture
    var copyVideo = false;
    video.addEventListener('playing', function () {
        vPlaying = true;
        checkReady();
    }, true);

    video.addEventListener('timeupdate', function () {
        vTimeupdate = true;
        checkReady();
    }, true);
    var vTexture, depthTexture;
    var vImage;

    // Shader vars
    var frameBuffer;
    var vertexShader;
    var fragmentShader;
    var groundFragShader;
    var shaderProgram;
    var groundShaderProgram;
    
    var eyeOffset = 0.0;
    var drawObjs;
    var objShaders;
    
    var vidClickX = -1;
    var vidClickY = -1;
    function videoClick(e) {
        var vidPos = cumulativeOffset(video);
        if (vidClickX != -1) {
            
            var height = (e.pageY - vidPos.top) - vidClickY;
            var sideLength = Math.abs(height) / Math.sqrt(3);
            var apothemX = Math.abs((e.pageX - vidPos.left) - vidClickX) / 2;
            var apothemY = height / 3;

            drawObjs[0].vertexTexCoords2 = new Float32Array(
                [(vidClickX + apothemX) / video.clientWidth, vidClickY / video.clientHeight,
                (vidClickX + apothemX - sideLength) / video.clientWidth, (e.pageY - vidPos.top) / video.clientHeight,
                (vidClickX + apothemX + sideLength) / video.clientWidth, (e.pageY - vidPos.top) / video.clientHeight]);
            for (var i = 0; i < drawObjs[0].triangleIndices2.length; i++) {
                drawObjs[0].vertexTexCoords[i * 2] = drawObjs[0].vertexTexCoords2[(i * 2 + 6) % 6];
                drawObjs[0].vertexTexCoords[i * 2 + 1] = drawObjs[0].vertexTexCoords2[(i * 2 + 7) % 6];
            }
            // a buffer for textures
            drawObjs[0].texBuff = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, drawObjs[0].texBuff);
            gl.bufferData(gl.ARRAY_BUFFER, drawObjs[0].vertexTexCoords, gl.STATIC_DRAW);
            drawObjs[0].texBuff.itemSize = 2;
            drawObjs[0].texBuff.numItems = 60;

            vidClickX = -1;
            vidClickY = -1;
        } else {
            vidClickX = (e.pageX - vidPos.left);
            vidClickY = (e.pageY - vidPos.top);
        }
    }

    function checkReady() {
        if (vPlaying && vTimeupdate) {
            copyVideo = true;
        }
    }

    // initialize our varaibles and start update function
    function init() {

        // rquest access to the camera
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true }).catch(function (err) { console.log(err.name + ": " + err.message); }).then(function (stream) { video.srcObject = stream; video.play(); });
        }

	    // Compile vertex shader
        vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader,document.getElementById("vs_simple").text);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(vertexShader)); return null;
        }

        groundFragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(groundFragShader, document.getElementById("fs_checkerboard").text);
        gl.compileShader(groundFragShader);
        if (!gl.getShaderParameter(groundFragShader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(groundFragShader)); return null;
        }
	    // Compile fragment shader
        fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader,document.getElementById("fs_video").text);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(fragmentShader)); return null; }
    
	    // Attach the shaders and link
        groundShaderProgram = gl.createProgram();
        gl.attachShader(groundShaderProgram, vertexShader);
        gl.attachShader(groundShaderProgram, groundFragShader);
        gl.linkProgram(groundShaderProgram);
        if (!gl.getProgramParameter(groundShaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialize shaders");
        }

	    // with the vertex shader, we need to pass it positions
	    // as an attribute - so set up that communication
        groundShaderProgram.PositionAttribute = gl.getAttribLocation(groundShaderProgram, "vPosition");
        gl.enableVertexAttribArray(groundShaderProgram.PositionAttribute);

        groundShaderProgram.NormalAttribute = gl.getAttribLocation(groundShaderProgram, "vNormal");
        gl.enableVertexAttribArray(groundShaderProgram.NormalAttribute);

        groundShaderProgram.ColorAttribute = gl.getAttribLocation(groundShaderProgram, "vColor");
        gl.enableVertexAttribArray(groundShaderProgram.ColorAttribute);

        groundShaderProgram.TexCoorAttribute = gl.getAttribLocation(groundShaderProgram, "vTexCoord");
        gl.enableVertexAttribArray(groundShaderProgram.TexCoorAttribute);

        // this gives us access to the matrix uniform
        groundShaderProgram.SunVector = gl.getUniformLocation(groundShaderProgram, "uSun");
        groundShaderProgram.WorldMatrix = gl.getUniformLocation(groundShaderProgram, "uWorld");
        groundShaderProgram.CameraMatrix = gl.getUniformLocation(groundShaderProgram, "uCamera");
        groundShaderProgram.PerspectiveMatrix = gl.getUniformLocation(groundShaderProgram, "uPerspective");
        
	    // Attach the shaders and link
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialize shaders"); }
        

	    // with the vertex shader, we need to pass it positions
	    // as an attribute - so set up that communication
        shaderProgram.PositionAttribute = gl.getAttribLocation(shaderProgram, "vPosition");
        gl.enableVertexAttribArray(shaderProgram.PositionAttribute);

        shaderProgram.NormalAttribute = gl.getAttribLocation(shaderProgram, "vNormal");
        gl.enableVertexAttribArray(shaderProgram.NormalAttribute);

        shaderProgram.ColorAttribute = gl.getAttribLocation(shaderProgram, "vColor");
        gl.enableVertexAttribArray(shaderProgram.ColorAttribute);

        shaderProgram.TexCoorAttribute = gl.getAttribLocation(shaderProgram, "vTexCoord");
        gl.enableVertexAttribArray(shaderProgram.TexCoorAttribute);

        // this gives us access to the matrix uniform
        shaderProgram.SunVector = gl.getUniformLocation(shaderProgram, "uSun");
	    shaderProgram.WorldMatrix = gl.getUniformLocation(shaderProgram, "uWorld");
	    shaderProgram.CameraMatrix = gl.getUniformLocation(shaderProgram, "uCamera");
        shaderProgram.PerspectiveMatrix = gl.getUniformLocation(shaderProgram, "uPerspective");

        // Set up texture
        vTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, vTexture);
        var pixel = new Uint8Array([255, 0, 0, 255]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        vImage = new Image();
        vImage.crossOrigin = "anonymous";
        
        // set up geometry
        var ico = new Icosahedron(0.0, 0.0, 0.0, 500.0, gl, [1.0, 0.0, 1.0], m4.identity(), "Video Ball");
        var ground = new Plane(0.0, 0.0, 0.0, 26500.0, 26500.0, gl, [0.0, 1.0, 0.0], m4.setTranslation(m4.axisRotation([1.0, 0.0, 0.0], -Math.PI / 2), [0.0, -500.0, 0.0]), "Ground");//m4.axisRotation([1.0, 0.0, 0.0], Math.PI/2));

        drawObjs = [ico, ground];
        objShaders = [shaderProgram,groundShaderProgram];
        drawObjs[0].velocities = [0.0, 0.0, 50.0];
        drawObjs[0].trajectory = [0.0, 0.0, 1.0];

        for (var i = 0; i < drawObjs.length; i++) {
            var tempOption = document.createElement('option');
            tempOption.text = drawObjs[i].name;
            tempOption.value = i;
            cntrl_view.add(tempOption);
        }

        window.requestAnimationFrame(update);
    };

    // update function
    function update() {
            // update local time values, delta variable, and fps counter
            currentTime = performance.now();
            if (currentTime - updateTime > 500) {
                document.getElementById("FPSContainer").textContent = Math.round(frameCount / ((currentTime - updateTime) / 1000));
                updateTime = currentTime;
                frameCount = 0;
            }
            delta = (currentTime - lastTime) / fps;
            lastTime = currentTime;
            frameCount++;

            if (copyVideo) {
                gl.bindTexture(gl.TEXTURE_2D, vTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            }
	    
            if (keyboard_input[65]) {
                eyeOffset -= 0.05 * delta;
            }
            if (keyboard_input[68]) {
                eyeOffset += 0.05 * delta;
            }
            var eye = [drawObjs[0].position[0] + 6000.0 * Math.cos((-Math.PI / 2 + eyeOffset)), 6000.0, drawObjs[0].position[2] + 6000.0 * Math.sin((-Math.PI / 2 + eyeOffset))];
            var target = [drawObjs[0].position[0], 0.0, drawObjs[0].position[2]];
            var up = [0, 1, 0];

            var tCamera = m4.inverse(m4.lookAt(eye, target, up));
            var tProjection = m4.perspective(Math.PI / 4, canvas.width / canvas.height, 10, 50000);

            if (document.getElementById("Run").checked) {
                var dir = normalize([drawObjs[0].position[0] - eye[0], drawObjs[0].position[2] - eye[2]]);

                drawObjs[0].velocities[0] -= (0.01 * delta) * drawObjs[0].velocities[0];
                drawObjs[0].velocities[1] -= (20.0 * delta); // gravity;
                drawObjs[0].velocities[2] -= (0.01 * delta) * drawObjs[0].velocities[2];

                var ntrajec = [dir[0] - drawObjs[0].trajectory[0], dir[1] - drawObjs[0].trajectory[2]];
                drawObjs[0].trajectory[0] = drawObjs[0].trajectory[0] + ntrajec[0];
                drawObjs[0].trajectory[2] = drawObjs[0].trajectory[2] + ntrajec[1];
                drawObjs[0].trajectory = normalize(drawObjs[0].trajectory);

                drawObjs[0].velocities[0] += (2.0 * keyboard_input[87] * delta * drawObjs[0].trajectory[0]) - (2.0 * keyboard_input[83] * delta * drawObjs[0].trajectory[0]);
                drawObjs[0].velocities[2] += (2.0 * keyboard_input[87] * delta * drawObjs[0].trajectory[2]) - (2.0 * keyboard_input[83] * delta * drawObjs[0].trajectory[2]);

                var pre = [drawObjs[0].position[0], drawObjs[0].position[2]];
                drawObjs[0].position[0] += drawObjs[0].velocities[0];
                drawObjs[0].position[1] += drawObjs[0].velocities[1];
                drawObjs[0].position[2] += drawObjs[0].velocities[2];

                if (drawObjs[0].position[0] > 13000.0) {
                    drawObjs[0].position[0] += 13000.0 - drawObjs[0].position[0];
                }
                if (drawObjs[0].position[0] < -13000.0) {
                    drawObjs[0].position[0] += -13000.0 - drawObjs[0].position[0];
                }
                if (drawObjs[0].position[1] < 0.0) {
                    drawObjs[0].position[1] = 0.0;
                    drawObjs[0].velocities[1] = 0.0;
                }
                if (drawObjs[0].position[2] > 13000.0) {
                    drawObjs[0].position[2] += 13000.0 - drawObjs[0].position[2];
                }
                if (drawObjs[0].position[2] < -13000.0) {
                    drawObjs[0].position[2] += -13000.0 - drawObjs[0].position[2];
                }

                var dis = Math.sqrt((drawObjs[0].position[0] - pre[0]) * (drawObjs[0].position[0] - pre[0]) + (drawObjs[0].position[2] - pre[1]) * (drawObjs[0].position[2] - pre[1]));
                if (dis < 0.1)
                    dis = 0.1;
                pre[0] = drawObjs[0].position[0] - pre[0];
                pre[1] = drawObjs[0].position[2] - pre[1];
                pre = normalize(pre);
                if (isNaN(pre[0]))
                    pre[0] = 0.0;
                if (isNaN(pre[1]))
                    pre[1] = 1.0;

                m4.multiply(m4.axisRotation(m4.transformDirection(m4.inverse(drawObjs[0].rtx), [pre[0] * Math.cos(-Math.PI / 2) - pre[1] * Math.sin(-Math.PI / 2), drawObjs[0].trajectory[1], pre[0] * Math.sin(-Math.PI / 2) + pre[1] * Math.cos(-Math.PI / 2)]), dis / drawObjs[0].r), drawObjs[0].rtx, drawObjs[0].rtx);
                m4.setTranslation(drawObjs[0].rtx, [drawObjs[0].position[0], drawObjs[0].position[1], drawObjs[0].position[2]], drawObjs[0].tx);
            }
            // Clear screen, prepare for rendering
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            //gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

            var Sun = [0.0, Math.sin(1.5 * Math.PI + Math.PI * 2 * cntrl_tod.value / cntrl_tod.max), Math.cos(1.5 * Math.PI + Math.PI * 2 * cntrl_tod.value / cntrl_tod.max)];

            for (var i = 0; i < drawObjs.length; i++) {
                gl.useProgram(objShaders[i]);

                var WorldTransform = drawObjs[i].tx;
                var CameraTransform = m4.multiply(drawObjs[i].tx, tCamera);
                var PerspectiveTransform = m4.multiply(m4.multiply(drawObjs[i].tx, tCamera), tProjection);

                // Set up uniforms & attributes
                gl.uniform3fv(objShaders[i].SunVector, Sun);
                gl.uniformMatrix4fv(objShaders[i].WorldMatrix, false, WorldTransform);
                gl.uniformMatrix4fv(objShaders[i].CameraMatrix, false, CameraTransform);
                gl.uniformMatrix4fv(objShaders[i].PerspectiveMatrix, false, PerspectiveTransform);

                gl.bindBuffer(gl.ARRAY_BUFFER, drawObjs[i].vertexBuff);
                gl.vertexAttribPointer(objShaders[i].PositionAttribute, drawObjs[i].vertexBuff.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, drawObjs[i].colorBuff);
                gl.vertexAttribPointer(objShaders[i].ColorAttribute, drawObjs[i].colorBuff.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, drawObjs[i].normalBuff);
                gl.vertexAttribPointer(objShaders[i].NormalAttribute, drawObjs[i].normalBuff.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, drawObjs[i].texBuff);
                gl.vertexAttribPointer(objShaders[i].TexCoorAttribute, drawObjs[i].texBuff.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, drawObjs[i].indexBuff);

                //gl.bindTexture(gl.TEXTURE_2D, vTexture);

                // Do the drawing
                gl.drawElements(gl.TRIANGLES, drawObjs[i].triangleIndices.length, gl.UNSIGNED_BYTE, 0);
            }
            window.requestAnimationFrame(update);
    };

    /*
            UTILITIES
    */

    // returns screen coordinates of DOM element
    function cumulativeOffset(element) {
        var top = 0, left = 0;
        do {
            top += element.offsetTop || 0;
            left += element.offsetLeft || 0;
            element = element.offsetParent;
        } while (element);

        return {
            top: top,
            left: left
        };
    };

    // converts array values into unit length
	function normalize(array) {
	    var tempArray = array;
	    var length = 0.0;
	    for (var i = 0; i < array.length; i++) {
	        length += tempArray[i] * tempArray[i];
	    }
	    length = Math.sqrt(length);
	    for (i = 0; i < array.length; i++) {
	        tempArray[i] = tempArray[i] / length;
	    }
	    return tempArray;
    }

    /*
            EVENT HANDLERS
    */

    // event for window resizing
    function myResize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };

    // event for mouse moving
    function myMouse(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    // event for keyboard key being pressed
    function myKeyDown(e) {
        try {
            keyboard_input[e.keyCode] = 1;
            if (keyboard_input[32]) {
                drawObjs[0].velocities[1] += 300.0 * (1 - key_space) * (drawObjs[0].position[1] == 0.0);
                key_space = true;
            };
        } catch (e) {
            console.log(e);
        }
    };

    // event for keyboard key being released
    function myKeyUp(e) {
        try {
            keyboard_input[e.keyCode] = 0;
            if (e.keyCode == 32) {
                key_space = false;
            };
        } catch (e) {
            console.log(e);
        }
    };

    // set event listeners
    window.onload = this.init;
    window.onresize = this.myResize;
    window.onmousemove = this.myMouse;
    window.onkeydown = this.myKeyDown;
    window.onkeyup = this.myKeyUp;
</script>
</html>